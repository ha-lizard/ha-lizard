#!/bin/bash

# chkconfig: 2345 99 01
# description: ha-lizard init script version 2.1 December 2016
# processname: ha-lizard

# shellcheck source=/dev/null

# Function library
. /etc/init.d/functions

PROC_NAME=ha-lizard
WATCHDOG=${PROC_NAME}-watchdog
WATCHDOG_EXEC=/etc/init.d/${WATCHDOG}
PID_FILE=/var/run/${PROC_NAME}.pid
LOCK_FILE=/var/lock/subsys/${PROC_NAME}
EXECUTE_NAME=ha-lizard.mon
EXECUTE_STRING=/usr/bin/${EXECUTE_NAME}
EXECUTE_PID_FILE=/var/run/${EXECUTE_NAME}.pid
GLOBAL_CONF=/etc/ha-lizard/ha-lizard.pool.conf
OVERRIDE_CONF=/etc/ha-lizard/ha-lizard.init
CALLED_BY=$(ps -o comm= $PPID)

# TODO: put all the sources together
source ${GLOBAL_CONF}
source ${OVERRIDE_CONF}

################################
## Function xapi_init_check
## adapted from Xenserver
################################
function xapi_init_check() {
  local count=0
  local max_wait=300 # 5 minutes timeout

  logger -t "${PROC_NAME}-init" "Waiting for XAPI to initialize"

  while [[ ${count} -lt ${max_wait} ]]; do
    if [[ -e "/var/run/xapi_init_complete.cookie" ]]; then
      logger -t "${PROC_NAME}-init" "XAPI initialized after ${count} seconds"
      return 0
    fi
    sleep 1
    ((count++))
  done

  logger -t "${PROC_NAME}-init" "Timeout waiting for XAPI initialization"
  return 1
}

# Clear iteration count on cold start/restart (skip for status)
if [[ "${1:-}" != "status" ]]; then
  if [[ -f "${MAIL_SPOOL}/count" ]]; then
    echo 0 >"${MAIL_SPOOL}/count"
  else
    mkdir -p "${MAIL_SPOOL}"
    echo 0 >"${MAIL_SPOOL}/count"
  fi
fi

start() {
  xapi_init_check
  local retval=$?
  if [[ ${retval} -ne 0 ]]; then
    failure "XAPI required to start"
    echo "Error: XAPI required to start"
    exit 1
  fi

  if [[ -e ${PID_FILE} && -s ${PID_FILE} ]] && kill -0 "$(cat "${PID_FILE}")" &>/dev/null; then
    failure "${PROC_NAME} is already running"
    echo "Error: ${PROC_NAME} is already running"
    exit 1
  fi

  nohup "${EXECUTE_STRING}" "${EXECUTE_PID_FILE}" &>/dev/null &
  local retval=$?

  if [[ ${retval} -eq 0 ]]; then
    /bin/touch $LOCK_FILE
    /bin/touch $PID_FILE
    pgrep -of $EXECUTE_STRING >$PID_FILE
    if [[ $WATCHDOG != $CALLED_BY* ]]; then
      echo -n $"Starting $PROC_NAME: "
      success
      echo
    fi

    # Check the status of the watchdog and start it if not running
    if ! "${WATCHDOG_EXEC}" status &>/dev/null; then
      $WATCHDOG_EXEC start
    fi
    exit 0
  else
    warning "Failed to start ${PROC_NAME}"
    echo "Error: Failed to start ${PROC_NAME}"
    rm -f "${LOCK_FILE}" "${PID_FILE}"
    exit 1
  fi
}

stop() {
  echo -n "Stopping ${PROC_NAME}: "
  killproc ${PROC_NAME} 2>/dev/null # Stop any active threads
  local retval=$?
  if [[ ${retval} -eq 0 ]]; then
    pkill "$(basename ${EXECUTE_STRING})" # Stop monitor
    rm -f "${LOCK_FILE}" &>/dev/null
    rm -f "${PID_FILE}" &>/dev/null

    if [[ -e ${EXECUTE_PID_FILE} ]]; then
      kill "$(cat ${EXECUTE_PID_FILE})" &>/dev/null # Stop monitor child processes
      rm -f ${EXECUTE_PID_FILE}
    fi

    echo
  else
    warning "Failed to stop ${PROC_NAME}"
    echo "Error stopping ${PROC_NAME}"
    failure
  fi
}

status() {
  if [[ -e ${PID_FILE} ]]; then
    local pid
    pid=$(cat ${PID_FILE})
    kill -0 "${pid}" 2>/dev/null
    local retval=$?
    if [[ ${retval} -eq 0 ]]; then
      success "${PROC_NAME} running: ${pid}"
      echo "${PROC_NAME} running: ${pid}"
      exit 0
    fi

    warning "${PROC_NAME} is dead and /var/run pid file exists"
    echo "${PROC_NAME} is dead and /var/run pid file exists"
    exit 1
  elif [[ -e ${LOCK_FILE} ]]; then
    warning "${PROC_NAME} is dead and /var/lock lock file exists"
    echo "${PROC_NAME} is dead and /var/lock lock file exists"
    exit 2
  else
    failure "${PROC_NAME} is not running"
    echo "${PROC_NAME} is not running"
    exit 3
  fi
}

case "$1" in
start)
  start
  ;;
stop)
  stop
  ;;
status)
  status
  ;;
restart)
  stop
  start
  ;;
*)
  echo "Usage: $0 {start|stop|restart|status|}"
  exit 1
  ;;
esac
